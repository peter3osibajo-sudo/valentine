<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Will You Be My Valentine? üíñ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Google Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      min-height: 100%;
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      font-family: 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
    }

    .card {
      background: #fff;
      padding: 30px;
      border-radius: 25px;
      text-align: center;
      width: min(92vw, 380px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      position: relative;
    }

    img.avatar {
      width: 170px;
      height: 170px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid #ff4d6d;
      margin: 0 auto 15px;
      display: block;
    }

    h1 { color: #ff4d6d; margin: 0 0 6px; }
    p  { margin: 8px 0 0; color: #444; }

    .buttons {
      position: relative;        /* keeps #no inside this region */
      height: 90px;              /* space so YES can grow without layout shift */
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      margin-top: 22px;
      user-select: none;
      touch-action: manipulation;
    }

    button {
      padding: 12px 22px;
      border-radius: 30px;
      border: none;
      font-size: 16px;
      cursor: pointer;
    }

    #yes {
      background: #ff4d6d;
      color: #fff;
      position: relative;
      z-index: 2;                 /* keep on top while it grows */
      transform-origin: center center;
      transition: transform .15s ease;
    }

    #no {
      background: #eee;
      color: #555;
      position: absolute;         /* we place it precisely inside .buttons */
      left: 0; top: 0;            /* JS sets true position after measuring */
      transform: translate(0,0);
    }

    /* Floating hearts up the screen */
    .heart {
      position: fixed;
      bottom: -20px;
      font-size: 22px;
      animation: floatUp 4s linear forwards;
      pointer-events: none;
      z-index: 9998;
    }
    @keyframes floatUp {
      to { transform: translateY(-110vh); opacity: 0; }
    }

    /* Pop-in animation */
    .pop { animation: pop .6s ease both; }
    @keyframes pop {
      0% { transform: scale(0); }
      80% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    /* YES growth when NO dodges (1‚Äì2x) */
    .grow { animation: growPulse .45s ease; }
    @keyframes growPulse {
      0%   { transform: scale(1); }
      60%  { transform: scale(var(--grow-to, 1.6)); }
      100% { transform: scale(1); }
    }

    /* üéâ Emoji confetti (hearts + flowers) */
    .emoji-confetti {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      font-size: 22px;
      will-change: transform, opacity;
      pointer-events: none;
      animation: emojiConfetti 1000ms cubic-bezier(.15,.65,.35,1) forwards;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.2));
      z-index: 9999;
    }
    @keyframes emojiConfetti {
      0%   { opacity: 1; transform: translate(-50%, -50%) rotate(0deg) scale(1); }
      100% { opacity: 0; transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) rotate(var(--rot)) scale(var(--scale)); }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      * { animation: none !important; transition: none !important; }
      .heart, .emoji-confetti { display: none !important; }
    }
  </style>
</head>
<body>
  <div class="card" id="card" aria-live="polite">
    <img src="peter.jpg" alt="Valentine photo" class="avatar" loading="lazy" />
    <h1>Will you be my Valentine? üíò</h1>
    <p>Say yes and make my day! üå∑</p>

    <div class="buttons" id="btnWrap" aria-label="Answer choices">
      <button id="yes" type="button" aria-label="Yes">Yes üíñ</button>
      <button id="no"  type="button" aria-label="No">No üôà</button>
    </div>
  </div>

  <script>
    // ===== Config =====
    const IMG_SRC = "peter.jpg"; // change if your image file has a different name

    // ===== Elements =====
    const card    = document.getElementById("card");
    const btnWrap = document.getElementById("btnWrap");
    const yesBtn  = document.getElementById("yes");
    const noBtn   = document.getElementById("no");

    // ===== Floating Hearts =====
    let heartTimer = null;
    function startHearts(){
      stopHearts();
      heartTimer = setInterval(() => {
        const heart = document.createElement("div");
        heart.className = "heart";
        heart.textContent = Math.random() < 0.3 ? "üíò" : "‚ù§Ô∏è";
        heart.style.left = (Math.random() * 100) + "vw";
        document.body.appendChild(heart);
        setTimeout(() => heart.remove(), 4200);
      }, 250);
    }
    function stopHearts(){
      if (heartTimer != null) { clearInterval(heartTimer); heartTimer = null; }
    }

    // ===== üéâ Emoji Confetti (hearts + flowers) =====
    const EMOJI_SET = ["üíñ","‚ù§Ô∏è","üíò","üå∏","üå∑","üåπ","üåº","üíê"];

    function burstEmojiConfettiAt(x, y, count = 120) {
      const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (prefersReduced) return;

      for (let i = 0; i < count; i++) {
        const span = document.createElement("span");
        span.className = "emoji-confetti";
        span.textContent = EMOJI_SET[i % EMOJI_SET.length];

        const angle = Math.random() * Math.PI * 2;          // 0‚Äì360¬∞
        const distance = 130 + Math.random() * 280;         // travel distance
        const dx = Math.cos(angle) * distance + "px";
        const dy = Math.sin(angle) * distance + "px";
        const rot = (Math.random() * 720 - 360) + "deg";
        const scale = (0.8 + Math.random() * 0.9).toFixed(2);

        span.style.fontSize = (18 + Math.random()*14) + "px";
        span.style.left = x + "px";
        span.style.top  = y + "px";
        span.style.setProperty("--dx", dx);
        span.style.setProperty("--dy", dy);
        span.style.setProperty("--rot", rot);
        span.style.setProperty("--scale", scale);

        document.body.appendChild(span);
        setTimeout(() => span.remove(), 1100);
      }
    }

    function getBurstPoint(e, fallbackEl){
      if (e && typeof e.clientX === "number" && typeof e.clientY === "number" && (e.clientX || e.clientY)) {
        return { x: e.clientX, y: e.clientY };
      }
      const r = fallbackEl.getBoundingClientRect();
      return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }

    // ===== Initial "No" placement so it doesn't overlap "Yes" =====
    window.addEventListener("load", lockNoPosition);
    window.addEventListener("resize", clampNoPosition);

    function lockNoPosition(){
      // Measure natural flex positions, then freeze #no there (absolute) so they stay separate
      const wrapRect = btnWrap.getBoundingClientRect();
      const noRect   = noBtn.getBoundingClientRect();
      const left = noRect.left - wrapRect.left;
      const top  = noRect.top  - wrapRect.top;

      noBtn.style.position = "absolute";
      noBtn.style.left = `${left}px`;
      noBtn.style.top  = `${top}px`;
      noBtn.style.transform = "translate(0,0)";
    }

    function clampNoPosition(){
      // Keep #no inside the buttons region after resize/orientation change
      const wrapRect = btnWrap.getBoundingClientRect();
      const noRect   = noBtn.getBoundingClientRect();
      let x = parseFloat(noBtn.style.left || "0");
      let y = parseFloat(noBtn.style.top  || "0");
      const pad = 4;
      const maxX = Math.max(pad, wrapRect.width  - noRect.width  - pad);
      const maxY = Math.max(pad, wrapRect.height - noRect.height - pad);
      x = Math.min(Math.max(pad, x), maxX);
      y = Math.min(Math.max(pad, y), maxY);
      noBtn.style.left = `${x}px`;
      noBtn.style.top  = `${y}px`;
    }

    // ===== "No" dodge + "Yes" grows 1‚Äì2x =====
    const rand   = (min, max) => Math.random() * (max - min) + min;
    const randInt= (min, max) => Math.floor(rand(min, max + 1));

    function growYesOnce(){
      const scale = rand(1.2, 2.0).toFixed(2);     // 1.2x ‚Äì 2.0x
      yesBtn.style.setProperty("--grow-to", scale);
      yesBtn.classList.remove("grow");             // restart animation if needed
      void yesBtn.offsetWidth;                     // force reflow
      yesBtn.classList.add("grow");
    }

    function moveNo(){
      const maxAttempts = 14;
      const wrapRect = btnWrap.getBoundingClientRect();
      const yesRect  = yesBtn.getBoundingClientRect();
      const noRect   = noBtn.getBoundingClientRect();

      const pad = 4;
      const maxX = wrapRect.width  - noRect.width  - pad*2;
      const maxY = wrapRect.height - noRect.height - pad*2;

      for (let i = 0; i < maxAttempts; i++) {
        const x = randInt(pad, Math.max(pad, Math.floor(maxX)));
        const y = randInt(pad, Math.max(pad, Math.floor(maxY)));

        const proposedLeft = wrapRect.left + x;
        const proposedTop  = wrapRect.top  + y;

        const overlap = !(
          proposedLeft + noRect.width  < yesRect.left  ||
          proposedLeft                 > yesRect.right ||
          proposedTop  + noRect.height < yesRect.top   ||
          proposedTop                  > yesRect.bottom
        );

        if (!overlap) {
          noBtn.style.left = `${x}px`;
          noBtn.style.top  = `${y}px`;
          growYesOnce();   // YES grows every time NO dodges
          return;
        }
      }

      // Fallback: still move somewhere (clamped)
      noBtn.style.left = `${randInt(pad, Math.max(pad, Math.floor(maxX)))}px`;
      noBtn.style.top  = `${randInt(pad, Math.max(pad, Math.floor(maxY)))}px`;
      growYesOnce();
    }

    // Make "No" dodge when approached or focused
    ["pointerover","pointerdown","mouseenter","touchstart","focus"].forEach(evt => {
      noBtn.addEventListener(evt, (e) => {
        e.preventDefault();
        moveNo();
        noBtn.blur();
      }, { passive: true });
    });
    // If a click sneaks through, dodge anyway
    noBtn.addEventListener("click", (e) => { e.preventDefault(); moveNo(); }, { passive: false });

    // ===== YES action: confetti + hearts + success state =====
    yesBtn.addEventListener("click", (e) => {
      const { x, y } = getBurstPoint(e, card);

      // üéâ Burst confetti at click/tap point (fallback: card center)
      burstEmojiConfettiAt(x, y, 140);
      setTimeout(() => burstEmojiConfettiAt(x, y, 90), 180);

      // Swap content to success message
      card.innerHTML = `
        <img src="${IMG_SRC}" alt="Valentine photo" class="avatar" loading="lazy" />
        <h1 class="pop">Yay!! üíñ</h1>
        <p class="pop">Awww, you love me! üòç</p>
      `;

      // Floating hearts celebration
      startHearts();
    });
  </script>
</body>
</html>
